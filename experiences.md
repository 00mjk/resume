## 3. Private Projects
> - https://github.com/samchon
> - https://sourcerer.io/samchon

### 3.1. TGrid
**T**ypescript **Grid** Computing Framework

  - 깃허브 저장소: https://github.com/samchon/tgrid
  - 가이드 문서: https://tgrid.com
  - API 문서: https://tgrid.com/api

TypeScript 로 만든 Grid Computing 프레임워크입니다.

모토는 "여러 대의 컴퓨터를 한 대의 가상 컴퓨터로 만들자" 이며, 이를 위해 [Remote Function Call](https://tgrid.com/ko/tutorial/concepts.html#12-remote-function-call) 이라는 개념을 사용합니다. 이 [Remote Function Call](https://tgrid.com/ko/tutorial/concepts.html#12-remote-function-call) 을 활용하면, 여러 대의 컴퓨터를 네트워크 통신으로 묶어 만드는 분산처리시스템의 프로그램 코드와, 한 대의 컴퓨터로 만드는 프로그램의 코드가 동일합니다.

### 3.2. TSTL
**T**ypescript **S**tandard **T**emplate **L**ibrary

  - 깃허브 저장소: https://github.com/samchon/tstl
  - API 문서: https://tstl.dev/api

**TSTL** 은 C++ 표준화위원회가 정의한 STL (Standard Template Library) 인터페이스를 TypeScript 로 구현한 프로젝트입니다. 동시에 [TGrid](#31-tgrid) 의 기반 라이브러리이기도 합니다. 지원하는 모듈 단위는 아래와 같습니다.

  - Container
  - Iterator
  - Algorithm
  - Functor

누군가는 왜 C++ STL 같이 거대한 표준 라이브러리 인터페이스를, 구태여 TS 에까지 구현했느냐라고 물으실 수도 있습니다. 그에 대한 이유를 말하자면, 처음에는 저의 업무 특성상 필요하다고 느껴서 그러하였습니다. 저는 업무 특성상 알고리즘을 주로 다루며, 스타일상 TS + HTML 조합으로 프로토타입을 먼저 만들어보고, 알고리즘 개념이 일정 수준 이상 잡혔다 판단되면 C++ 로 마이그레이션하면서 퍼포먼스 튜닝을 합니다. 이 때, JS 의 부실한 기저 라이브러리를 보충하고, 더불어 C++ 로의 마이그레이션을 수월케 하기 위하여 **TSTL** 을 만들었습니다.

두 번째 이유는 [TGrid](#31-tgrid) 의 기반을 다지고, [Remote Critical Section](https://tgrid.com/ko/tutorial/examples.html#4-remote-critical-section) 을 구현하기 위함입니다. 때문에 **TSTL** 은 [TGrid](#31-tgrid) 가 제작되기 훨씬 전부터 오래도록, 본래라면 싱글 스레드 기반인 JS 특성상 개발할 필요가 전혀 없는, `<thread>` 모듈을 지원하고 있었습니다.

  - 관련 이슈: https://github.com/samchon/tstl/issues/22

### 3.3. Samchon Framework
OON (Object Oriented Network) Framework

  - 깃허브 저장소: https://github.com/samchon/framework
  - API 문서: http://samchon.github.io/framework/api/cpp/

저는 업무 특성상 분산처리시스템 (또는 Grid Computing 시스템) 을 자주 다루었습니다. 그리고 그 때마다 네트워크 시스템을 만들 때, 그 시스템의 본 목적인 비지니스 로직보다, 네트워크 프로그래밍 자체가 더 까다롭더라는 지극히 단순한 사실을 뼈저리게 느끼게 됩니다.

이에 네트워크 시스템을 구성하는 각 노드를 객체 (an object) 마냥 다룰 수 있다면 보다 편하지 않을까? 라는 생각을 하게 되었고, 이를 실천하기 위하여 만든 게 바로 이 Samchon Framework 입니다. 그리고 이 패러다임을 객체지향 네트워크라 이름 지었습니다.

다만, Samchon Framework 는 현재 개발이 중단된 프로젝트입니다. 제가 Samchon Framework 를 한창 개발하던 중, [Remote Function Call](https://tgrid.com/ko/tutorial/concepts.html#12-remote-function-call) 이란 개념을 발명했기 때문입니다. 그리고 Samchon Framework 에서 목적하던 바는 [TGrid](#31-tgrid) 에서 완벽하게 실현됩니다.

### 3.4. Samchon Simulation
  - 데모 사이트: http://samchon.org/simulation
  - 매뉴얼: http://samchon.org/portfolio/Samchon_Simulation/Manual-KR.pdf

제가 대학교를 다니던 시절에 만들던 프로그램입니다.

주제는 주가 시뮬레이션 및 오토 트레이딩에 관한 것이며, 나름 코드 규모가 30 만 라인에 달하는 방대한 프로젝트이기도 합니다. Samchon Simulation 은 처음 만들 때부터 그 규모가 상당하리란 걸 쉬이 예상할 수 있었고, 저는 이를 아키텍처 설계 없이 제작하기란 거의 불가능다고 판단하였습니다.

따라서 이 프로그램을 만들기 위하여 아키텍처 설계를 무수히 반복할 수 있었고, 그 덕에 졸업할 때 즈음에는 나름 한 아키텍처 설계 한다고 자부할 수 있을만큼 숙달되었습니다.




## 4. Commercial Projects
### 4.1. OraQ, Selene TR-1
클라우드 기반 DICOM (PACS) 미디어 관리도구 및 뷰어

  - 근무 회사: 스마트케어웍스
    - 공급처: 일본 고베병원 등
    - 기간: 4 달
    - 기여도: 70 %
  - 언어
    - C++
    - Flex/AS3
    - Pixel Bender
    - MSSQL
  - 매뉴얼
    - http://samchon.org/portfolio/OraQ/Manual_20150126.pdf
    - http://samchon.org/portfolio/OraQ/Development_Guide-EN.pdf

#### 4.1.1. Hardcore Difficulty
OraQ (일본에서는 Selene TR-1) 는 제가 대학교를 졸업하고나서 처음 개발했던 상용 프로젝트입니다. 그리고 제가 개발했던 모든 상용 프로젝트들을 통틀어서, 가장 난이도가 높았으며, 기한 또한 제일 급박하였습니다.

당시 회사 (스마트케어웍스) 는 이미 5 년 전에 이 프로젝트에 대한 계획을 세워두고 있었으되, 이를 개발해 줄 수 있는 개발자가 없어 하염없이 세월만 지새우고 있었습니다. 그나마 웹 개발자를 구하여 프로젝트를 진행하였으되, 개발에 실패하고 해당 개발자는 속칭 빤쓰런을 하게 됩니다. 그리고 이 프로젝트의 만료 기일은 어느덧 4 달 앞으로 성큼 다가와버린 상태였죠.

저는 이런 속사정 모르고, 그저 간단한 웹 사이트나 만드는 프로젝트 정도로만 이야기를 들은채로, 프리랜서 계약을 하게 됩니다. 그리고 얼마 지나지 않아, 제가 만들어야 할 프로젝트의 실체를 알게 됩니다.

  - DICOM 미디어는 이미지 한 장에 수백 MB ~ 수 GB 에 이른다.
  - 의사는 이러한 이미지 수백장에 실시간으로 블러 효과 등을 주어가며 관찰한다.
    - 마우스 (휠) 스크롤시 끊김없이 실시간 변화가 가능해야 함
    - 이미지 프로세싱으로 인해 끊김 현상이 있어서는 안 됨
  - 해당 클라우드 시스템은 동시에 여러명이 쓰며, 이들간에 동기화가 이루진다.
  - 사용자 컴퓨터의 CD 드라이브로부터 DICOM 미디어 정보를 불러와 PACS 에 기록할 수 있다.
  - <u>이 모든 것이 웹 브라우저에서 가능해야 한다.</u>

그리고 DICOM 이나 PACS 에 연동을 위해 필요한 외부 라이브러리는 모두 C++ 로 제작되어 있었으며, 서버에서는 클라이언트들과 실시간으로 통신하며 상당한 수준의 임계영역 제어가 이루어져야 했습니다. 게다가 당시에는 웹 브라우저에서 GPU 프로그래밍을 할 수 있던 시절도 아니었고, Web Socket 도 이제 막 걸음마를 떼기 시작한 단계였습니다.

따라서 OraQ 는 당시의 웹 브라우저 기술이나, 전통적인 웹 서버 기술스택 (JSP, PHP 등) 로 만들 수 있는 성질의 것이 아니었습니다. 이를 인지한 순간, 프로젝트 도중에 도망친 전임 웹 개발자가 나름 합리적인 판단을 했다고 느껴지기까지 했습니다.

#### 4.1.2. New Development
프로젝트의 난이도가 워낙 높은지라 자칫하면 실패할 수도 있겠다 생각이든 저는, 이왕 이렇게 된 거 과감한 도전과 실험이라도 해보면 뭐라도 배우고 얻어가는 게 있겠지라는 심정으로, 기존의 모든 전통적인 개발스택을 포기하고 과감히 새로운 시도를 하게 됩니다.

먼저 클라우드 서버 전체를 C++ 로 만들기로 합니다. 그리하면 DICOM 미디어 및 PACS 와의 원활한 연동이 가능해질 것이고, 중대 임계영역 제어 또한 직접 할 수 있게 됩니다. 더불어 프론트와의 실시간 연동 역시 소켓 프로그래밍을 통해 직접 구현하면, 방대한 데이터 전송량을 필요에 따라 적절히 제어하고 최적화할 수 있게 됩니다.

프론트 프로그램은 Flex 로 만들기로 합니다. Flex 는 Flash Player 기반의 프레임워크로써, 당시에는 Flash 만이 유일하게 웹 브라우저에서 GPU 프로그래밍을 할 수 있었습니다. 더불어 카메라나 CD 드라이브같은 하드웨어 장비를 제어할 수도 있었습니다. 게다가 웹 브라우저에서 커스텀 소켓 프로그래밍이 가능한 유일한 언어이기도 했습니다. 지금이야 웹 브라우저에서 퇴출될 위기에 몰린 Flex (Flash) 지만, 당시에는 OraQ 를 구현할 수 있는 유일한 도구였습니다.

마지막으로 철저한 아키텍처 설계와 정책 수립을 제 1 의 원칙으로 삼았습니다. 족보에도 없는 전혀 새로운 방법으로 개발하는 클라우드 시스템인만큼, 그 어떤 노하우나 도움을 구할 수도 없었기 때문입니다. 어중간한 하드코딩은 프로젝트를 파멸로 치닫게 할 것이며, 오로지 철두철미한 계획과 원칙을 지켜나가는 완고함만이 프로젝트를 성공으로 이끌어가는 유일한 열쇠라고, 저는 그리 믿고 행동하였습니다.

#### 4.1.3. Later Story
철저한 아키텍처 설계와 원칙을 지켜나가는 완고함, 그리고 기존의 개발스택을 과감히 버리고 새로운 방식으로의 개발을 시도한 끝에, OraQ 는 실로 4 개월만에 완성되어 정상 출시할 수 있었습니다. 게다가 설계 과정에서 만들었던 아키텍처와 각종 문서들이 매뉴얼을 좋아하는 일본 사람들의 취향에 맞았는지, 업계에서는 소소한 파란을 일으키어, 데모 단계에서부터 일본의 고베병원 등이 OraQ 솔루션을 선 구매하는 기적이 일어나기까지 했습니다

> 출시가 안 된 제품을 선 계약하는 것은 당시 업계에서 처음 있던 일이라고 합니다.

다만, 이후 회사의 행보는 다소 이해하기 어려웠습니다. 회사는 우선 비용을 줄이기 위하여 무던히 노력하였고, 그 일환으로써 저와의 계약을 연장하지 않았습니다. 그 결과 일본으로부터 빗발치는 패치 및 유지보수 요구에 대응하지 못하여, OraQ 라는 프로젝트는 적자는 아니되 큰 성공을 거둔것도 아닌, 어중간한 반쪽짜리 프로젝트로 끝나게 됩니다. 3 개 병원을 끝으로 추가 구매자가 나타나지 않았던 것입니다.

> 제가 의사나 의료계 종사자도 아닌데, DICOM 미디어에 대한 현장의 세세한 요구사항까지 어찌 알겠습니가? OraQ 는 한정된 기간 내에 주어진 스펙과 기능 구현에 충실한 제품이었을지는 몰라도, 사용자들의 가려운 곳을 긁어주는 그런 노하우를 가진 그런 프로그램은 아니었습니다. 
> 
> 따라서 출시 후 유지보수의 요구가 빗발칠 것은 뻔히 보였는데, 회사는 어쩌다가 소탐대실의 오판을 해버린 것인지 지금도 잘 이해가 안 갑니다.

다만, 회사는 막판의 오판으로 인하여 대박의 기회를 놓쳤어도, 저는 그 기회를 놓치지 않았습니다. 프로젝트가 대성할 수도 있었다는 아쉬움은 뒤로 한 채, 4 개월 간에 거두었던 성과를 가지고 다른 회사의 문을 두드렸습니다. 그리고 바로 이 성과 덕분에, 대졸 신입사원은 그 어떤 회사를 들어가도, 시작부터 코어 아키텍처를 설계하고 핵심 알고리즘을 연구하고 개발할 수 있는 기회를 부여받게 됩니다.

지금도 가끔 생각합니다. 대학교를 졸업하고 첫 경력으로 맡은 프로젝트가 OraQ 인데, 이런 기회가 생기는 것은 개발자들 중에서도 정말 극소한 케이스로, 매우 운이 좋았더라고 말입니다. 만일 제가 대학교를 졸업하고나서 처음 맞이한 프로젝트가 OraQ 가 아니라, 평범한 회사에 다니면서 평범하게 신입 개발자로 경력을 시작했더라면, 과연 이후로도 그런 파격과 기회들이 주어지기나 했을까요?

### 4.2. Torpedo Simulator Communication Module
잘못된 하드웨어 설계를 SDN 으로 해결하기

  - 근무 회사: 유니텍 해양연구소
    - 발주처: 해군
    - 기간: 2 달
    - 기여도: 0 %
  - 언어: C++

해군에서 어뢰 시뮬레이터를 제작하는데, 그것의 물리적인 형태는 여러 대의 컴퓨터를 온보드에 납땜하여 장착한, 다소 기괴한 모습이었습니다. 그리고 더 기괴했던 것은, 각 컴퓨터 간에 네트워크 연결구조가 물리적으로 잘못 이어져있었다는 것입니다.

제일 좋은 방법은 하드웨어를 다시 설계하여 제작하는 것이었으나, 그것은 이미 생산까지 다 마쳐둔 상태였습니다. 저는 이 문제를 해결하기 위하여 일종의 SDN (Software Defined Network) 시스템을 구현하였습니다. 물리적으로 해결할 수 없으니 소프트웨어적으로, 네트워크에 일종의 Proxy 나 Chain of Responsibility 같은 패턴을 도입하였습니다. 이를 통하여 물리적으로 잘못 맺어진 네트워크 관계를 논리적으로 해소하는 데에 성공하였습니다.

저 개인적으로는 이 프로젝트가 참 재미나고 유익하였습니다. 다만, 해당 프로젝트는 비지니스적인 이유로 도중에 흐지부지 중단되어버렸습니다. 그 때 당시 저는 매우 아쉽기도 했지만, 한편으로는 재미나고 귀중한 경험을 하나 해 봤다, 그리 생각하고 있습니다.

### 4.3. TSP, Construction Schedule Optimizer
TSP (Traveling Salesman Problem) 솔루션

  - 근무 회사: 히즈윌
    - 기간: 2 주
    - 기여도: 80 %
  - 언어: C++

지금도 그런지는 모르겠습니다만, 히즈윌에서 최적화 알고리즘을 개발할 연구원을 뽑을 때는, 독특하게도 과제성 프로젝트를 내줍니다. 히즈윌에서 저에게 내주었던 과제 프로젝트는, 전국 수 천 개의 지점을 돌아다니며 공사를 해야하는 시공팀의, 순회 일정을 최적화시켜주는 프로그램을 만드는 것이었습니다.

당시의 저는 이를 K-means 알고리즘과 Factorial 을 적절히 섞어가며 해결하였습니다. 그리고 이 때부터 저는, 히즈윌에서 근 1 년간 최적화 알고리즘을 연구하고 개발하게 됩니다.

### 4.4. Packer, 3D Bin Packing
공간 활용도의 최적화

  - 근무 회사: 히즈윌
    - 기간: 2 달
    - 기여도: 70 %
  - 언어: TypeScript
    - https://github.com/betterwaysystems/packer

3D Bin Packing 은 3 차원 공간 활용도에 대한 최적화 솔루션으로써, '물건을 여러 트럭에 나누어 실어야 하는데, 어떻게 배치를 하면 공간 활용도를 극한으로 끌어올리어 배차 수를 줄일 수 있을까?' 라는 질문에 대한 명쾌한 해답을 줍니다.

이 솔루션을 개발할 때, 정말 별의별 시도를 다 해봤었습니다. 3D 공간에 대한 이해도를 늘리기 위하여, 골판지 박스를 구해와 육면에 각각 숫자를 적고 요리조리 돌려보기도 했고, 실증 프로그램을 제작하기 위해 난생 처음 3D 랜더링까지 해야 했습니다. 핵심 알고리즘 개발은, 때마침 미 공군에서 발행한 3 차원 공간 활용 최적화에 대한 논문이 있었기에, 이를 통해 큰 도움을 받았습니다.

그리고 이 시절에 익힌 Bin Packing 에 대한 노하우는, 이후의 최적화 프로젝트들에 요긴하게 사용되었습니다.

### 4.5. Folder, Paper Cutting
접지 최적화 프로그램

  - 근무 회사: 히즈윌
    - 기간: 2 달
    - 기여도: 80 %
  - 언어: TypeScript

제본을 할 때 사용되는 용지는 각 페이지의 크기보다 훨씬 큰 것을 사용합니다. 예를 들어서 각 페이지의 크기가 A4 인 책을 제작하고자 할 때, 이를 A1 에 인쇄하여 한 면당 8 페이지씩을 출력할 수 있습니다. 인쇄가 끝난 후엔 이를 3 번 접어서 제본한 후 책으로 제작하게 됩니다.

책을 대량으로 제본하는 경우, 사용하는 공정의 종류에 따라 그 가격이 천차만별로 달라지게 됩니다. 마찬가지로 공정에 따라 사용할 수 있는 용지의 최대 크기 역시 달라집니다. 더불어 전체 페이지 수와 생산 부수에 따라서도 최적화 방식이 달라지며, 페이지를 배분거나 배치하는 방식조차도 단가에 영향을 주니 주의하여야 합니다.

아무튼 `Folder` 는 이런 접지에 대한 최적의 방안을 탐색하는 솔루션입니다. 이 접지에 대해서는 이래저래 글로 쉬이 설명하기 힘듭니다. 잘 이해가 안 가신다면, 그저 책을 만드는 방식에 대해 또다른 종류의 [Bin Packing](#44-packer-3d-bin-packing) 알고리즘이 존재한다고 생각하시면 됩니다.

### 4.6. Distributed Button Finder
유사 이미지 검색의 분산처리 시스템 구축

  - 근무 회사: 히즈윌
    - 기간: 2 달
    - 역할
      - 프론트 프로그램 개발
      - 분산처리시스템 구축
    - 기여도: 70 %
  - 언어
    - C++
    - TypeScript

히즈윌이라는 회사는 인쇄를 전문 업으로 하는 회사로써 (브랜드명 레드프린팅), 그곳의 공장에서는 수십만 종에 이르는 인쇄물이 생산되고는 합니다. 그리고 생산 완료된 각 인쇄물의 원 주문자를, 사람의 눈과 손으로 찾는 것은 매우 고된 일입니다.

때문에 회사는 이 어려움을 해소하기 위하여, 유사 이미지 검색 알고리즘을 사용하기로 합니다. 단, 워낙 후보 이미지 개수가 많은 관계로, 이를 단 한 대의 서버로 처리한다는 것은 있을 수 없는 일이었습니다. 따라서 여러 대의 컴퓨터를 묶는, 분산처리시스템을 구축해야 했습니다.

그리고 이 프로젝트에서 본인의 역할이 바로, 해당 분산처리시스템을 구축하는 것이었습니다. 이외에도 프론트 프로그램까지 본인이 제작하게 되었으며, 유사 이미지 검색 알고리즘은 다른 회사의 라이브러리를 구매하여 사용하였습니다.